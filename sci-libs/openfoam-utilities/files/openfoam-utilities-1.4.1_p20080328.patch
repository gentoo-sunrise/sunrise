Index: postProcessing/dataConversion/foamToVTK/writeFuns.C
===================================================================
--- applications/utilities/postProcessing/dataConversion/foamToVTK/writeFuns.C	(Revision 30)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/writeFuns.C	(Revision 569)
@@ -229,14 +229,36 @@
 void Foam::writeFuns::insert(const vector& pt, DynamicList<floatScalar>& dest)
 {
     for (direction cmpt = 0; cmpt < vector::nComponents; cmpt++)
     {
         dest.append(float(pt[cmpt]));
     }
 }
+void Foam::writeFuns::insert
+(
+    const symmTensor& pt,
+    DynamicList<floatScalar>& dest
+) 
+{ 
+    for (direction cmpt = 0; cmpt < symmTensor::nComponents; cmpt++) 
+    { 
+        dest.append(float(pt[cmpt])); 
+    } 
+} 
+void Foam::writeFuns::insert
+(
+    const sphericalTensor& pt,
+    DynamicList<floatScalar>& dest
+) 
+{ 
+    for (direction cmpt = 0; cmpt < sphericalTensor::nComponents; cmpt++) 
+    { 
+        dest.append(float(pt[cmpt])); 
+    }
+}
 void Foam::writeFuns::insert(const tensor& pt, DynamicList<floatScalar>& dest)
 {
     for (direction cmpt = 0; cmpt < tensor::nComponents; cmpt++)
     {
         dest.append(float(pt[cmpt]));
     }
 }
Index: postProcessing/dataConversion/foamToVTK/writeFuns.H
===================================================================
--- applications/utilities/postProcessing/dataConversion/foamToVTK/writeFuns.H	(Revision 30)
+++ applications/utilities/postProcessing/dataConversion/foamToVTK/writeFuns.H	(Revision 569)
@@ -167,14 +167,16 @@
         const label,
         const label
     );
 
     //- convert to VTK and store
     static void insert(const scalar&, DynamicList<floatScalar>& dest);
     static void insert(const point&, DynamicList<floatScalar>& dest);
+    static void insert(const symmTensor&, DynamicList<floatScalar>& dest);
+    static void insert(const sphericalTensor&, DynamicList<floatScalar>& dest);
     static void insert(const tensor&, DynamicList<floatScalar>& dest);
 
     //- Append elements to DynamicList
     static void insert(const labelList&, DynamicList<label>&);
     template<class Type>
     static void insert(const List<Type>&, DynamicList<floatScalar>&);
 

Index: mesh/manipulation/Optional/Allwmake
===================================================================
--- applications/utilities/mesh/manipulation/Optional/Allwmake	(Revision 30)
+++ applications/utilities/mesh/manipulation/Optional/Allwmake	(Revision 569)
@@ -1,11 +1,11 @@
 #!/bin/sh
 
 READLINE=0
 if [ -f /usr/include/readline/readline.h ]; then
     echo "Found readline/readline.h include file. Enabling readline support."
     READLINE=1
-    export READLINELINK="-lreadline"
+    export READLINELINK="-lreadline -lcurses"
     break
 fi
 export READLINE
 wmake setSet

Index: mesh/conversion/ideasUnvToFoam/ideasUnvToFoam.C
===================================================================
--- applications/utilities/mesh/conversion/ideasUnvToFoam/ideasUnvToFoam.C	(Revision 30)
+++ applications/utilities/mesh/conversion/ideasUnvToFoam/ideasUnvToFoam.C	(Revision 569)
@@ -276,26 +276,26 @@
             is.getLine(line);
         }
         else if (feID == 171)
         {
             // Rod. Skip.
             is.getLine(line);
         }
-        else if (feID == 41)
+        else if (feID == 41 || feID == 91)
         {
             // Triangle. Save - used for patching later on.
             is.getLine(line);
 
             face cVerts(3);
             IStringStream lineStr(line);
             lineStr >> cVerts[0] >> cVerts[1] >> cVerts[2];
             boundaryFaces.append(cVerts);
             boundaryFaceIndices.append(cellI);
         }
-        else if (feID == 94)
+        else if (feID == 44 || feID == 94)
         {
             // Quad. Save - used for patching later on.
             is.getLine(line);
 
             face cVerts(4);
             IStringStream lineStr(line);
             lineStr >> cVerts[0] >> cVerts[1] >> cVerts[2] >> cVerts[3];
@@ -389,29 +389,38 @@
         faceIndices.setSize(nFaces);
         label faceI = 0;
 
         while (faceI < faceIndices.size())
         {
             is.getLine(line);
             IStringStream lineStr(line);
-            label typeCode1, tag1, nodeLeaf1, component1,
-                typeCode2, tag2, nodeLeaf2, component2;
-            lineStr
-                >> typeCode1 >> tag1 >> nodeLeaf1 >> component1
-                >> typeCode2 >> tag2 >> nodeLeaf2 >> component2;
 
-            if (typeCode1 != 8 || typeCode2 != 8)
+            // Read one (for last face) or two entries from line.
+            label nRead = 2;
+            if (faceI == faceIndices.size()-1)
             {
-                FatalErrorIn("readPatches")
-                    << "When reading patches expect Entity Type Code 8" << nl
-                    << "At line " << is.lineNumber() << exit(FatalError);
+                nRead = 1;
             }
 
-            faceIndices[faceI++] = tag1;
-            faceIndices[faceI++] = tag2;
+            for (label i = 0; i < nRead; i++)
+            {
+                label typeCode, tag, nodeLeaf, component;
+
+                lineStr >> typeCode >> tag >> nodeLeaf >> component;
+
+                if (typeCode != 8)
+                {
+                    FatalErrorIn("readPatches")
+                        << "When reading patches expect Entity Type Code 8"
+                        << nl << "At line " << is.lineNumber()
+                        << exit(FatalError);
+                }
+
+                faceIndices[faceI++] = tag;
+            }
         }
     }
 
     patchNames.shrink();
     patchFaceIndices.shrink();
 }
 
@@ -688,15 +697,15 @@
     // sets (dofVertIndices).
 
     List<faceList> patchFaceVerts;
 
 
     if (dofVertIndices.size() > 0)
     {
-        // Use the vertex constraints to patch. Is of course bit dodge since
+        // Use the vertex constraints to patch. Is of course bit dodgy since
         // face goes on patch if all its vertices are on a constraint.
         // Note: very inefficient since goes through all faces (including
         // internal ones) twice. Should do a construct without patches
         // and then repatchify.
 
         Info<< "Using " << dofVertIndices.size()
             << " DOF sets to detect boundary faces."<< endl;

